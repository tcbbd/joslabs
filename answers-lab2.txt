Lab2 问题回答
丁卓成 5120379064

Question 1.
    x应该是一个uintptr_t类型的变量，因为指针value可以被解引用，因此它一定对应着虚拟地址，故x应为uintptr_t类型。

Question 2.
    ---------------------------------------------------------------------------------------------
    |Entry | Base Virtual Address |                    Points to (logically):                   |
    ---------------------------------------------------------------------------------------------
    | 1023 |      0xFFC00000      |            Page table for top 4 MB of phys memory           |
    ---------------------------------------------------------------------------------------------
    | 1022 |      0xFF800000      |   Page table for the 4MB just below top 4MB of phys memory  |
    ---------------------------------------------------------------------------------------------
    | .... |         ...          |                 Page tables for phys memory                 |
    ---------------------------------------------------------------------------------------------
    |  961 |      0xF0400000      | Page table for the 4MB just above bottom 4MB of phys memory |
    ---------------------------------------------------------------------------------------------
    |  960 |      0xF0000000      |            Page table for bottom 4MB of phys memory         |
    ---------------------------------------------------------------------------------------------
    |  959 |      ----------      |                   This entry is not filled                  |
    ---------------------------------------------------------------------------------------------
    |  958 |      0xEF800000      |        Page table containing entries for kernel stack       |
    ---------------------------------------------------------------------------------------------
    |  957 |      0xEF400000      |                     Page directory itself                   |
    ---------------------------------------------------------------------------------------------
    |  956 |      0xEF000000      |  Page table containing entries for read only page stuctures |
    ---------------------------------------------------------------------------------------------
    | .... |         ...          |                  These entries are not filled               |
    ---------------------------------------------------------------------------------------------
    |   0  |      ----------      |                   This entry is not filled                  |
    ---------------------------------------------------------------------------------------------

Question 3.
    通过内存管理机制来保护内核的内存。它分为两部分，页式内存管理中，PDE、PTE中只有前20位表示物理地址，后12位则作为flag，其中有用于权限管理的位（读写位和内核/用户位）；段式内存管理中，段选择子的最后两位表示Privilege Level，一般取0为内核态，3为用户态，1和2给驱动程序使用。两者结合起来，就实现了内存的权限控制，将内核内存从用户手中保护了起来。

Question 4.
    由于i386_detect_memory函数没有取CMOS中第三项内存size数据，最多只能识别出64M+640K的物理内存，当然也就只能管理这么多内存。从其虚拟地址空间的布局来看，JOS的设计意图应该是最多管理256M物理内存（从KERNBASE到4G空间顶部），因为当物理内存数量小于等于256M时可以直接建立PA与VA之间的映射。
    当然，如果把KERNBASE的位置移动，即可实现管理物理内存数量的增长，但这是有限度的。因为留给pages数组和Page Table（第二级页表）的空间不足4M，不可能支持过多的物理内存。根据测试pages数组起始地址为0xf0117000，由此可以算得可供使用的内存有 (640 - 4) + (0x400000 - 0x117000) / 1024 = 3616K。考虑会占用该部分空间的内容，其一，pages数组，由于对齐问题，struct Page只有6字节内容但占据了8字节空间，pages数组共占据npages*8字节空间；其二，kernel stack，需要一张Page Table，使用4K空间；其三，UPAGES开始的Read Only pages，需要一张Page Table，使用4K空间（由于struct Page占用8字节，一张Page Table能映射4M内存共代表0.5M个Page，从这一点看JOS的设计只能支持2G物理内存，不过后面将看到起始的4M映射能支持的物理内存就小于2G了）；其四，KERNBASE以上空间的映射，需要若干页表。此处我们按之前的设计思路，希望KERNBASE以上空间能映射全部物理内存，不妨让两者容量相同，并且忽略一些细节，假设物理内存的容量以及KERNBASE的值都是4M对齐的。这样，总共占据npages*8 + 4K + 4K + (npages/1K)*4K = 8K + 12*npages = 3616K空间，npages=300.67K，物理内存总量为1202.67M=1.17G。
    综上所述，若保持JOS设计的memlayout不变，通过改变KERNBASE，理论上最多有可能支持到1.17G的物理内存，然而设计者可能只试图支持小于等于256M的物理内存，并且在设计时由于疏忽（或故意如此以简化学生写作业时的工作）只能检测64M略多的物理内存。OS若要支持更多的物理内存，则可以采用window的方式而不是将物理内存全部映射到虚拟地址空间的方式管理，但这样的设计就不属于JOS的范畴了。

Question 5.
    以Lab代码中实际的最大值64M计，Overhead为8K + 12 * (64M / 4K) = 200K;以KERNBASE以上空间大小256M计，Overhead为8K + 12 * (256M / 4K) = 776K，从绝对数量来看不大，但从比例来看还是较大的，如果按照现在较普遍的8G、16G内存来算，为管理内存而设立的数据结构就要占几十M空间。为了减少overhead，最简单的就是不需要把物理内存全部映射到虚拟地址空间的顶部，只需通过一个window即可，这样减少了不少Page Table（二级页表）的分配。更进一步，可以考虑换一种空间利用率更高的数据结构来管理物理页的状态，显然我们可以将相邻的空闲Page合并成一个chunk来考虑，减少空间占用，例如Linux就是采用Buddy System实现物理页的管理的。

Question 6.
    在entry.S的66、67行mov $relocated, %eax; jmp *%eax语句转移了EIP，前一句向eax载入新的高位地址，后一句将EIP跳转到该地址，完成了EIP的转移。通过加载初始页表entrypgdir，我们将物理地址[0, 4M)同时映射到了虚拟地址[0,4M)和[KERNBASE, KERNBASE + 4M)，因此可以实现EIP继续在低地址运行而后跳转到高地址这一系列平滑过度。
    最后一问，问到为何这个转移是必要的。我认为不一定是必要的，其转移到高地址的必要性是相对于JOS所设计的内存布局而言的，因为JOS将物理内存映射到KERNBASE以上的空间，它必定要把虚拟地址空间的高地址部分作为kernel space，并且要让kernel运行在高地址的kernel space内，和低地址的user space形成隔离。这种设计应该是借鉴了Linux和Windows的虚拟地址空间布局，其实不一定要以这种方式划分kernel space和user space，将kernel space分成两部分一部分在地址空间的最底部，另一部分在最顶部，中间是user space，也不失为一种分法，那么boot时的内存仍旧放在地址空间的最底部不进行EIP的转移在这种情况下就是可行的了。
    因此，与其说将EIP转移到高地址是必须的、必要的操作，不如说开启页表，区分kernel space和user space才是每个OS必须完成的工作，至于具体的实现方式，只是一种手段，手段可以不同，但目的是相同的。
