Lab5 问题回答
丁卓成 5120379064

Question 1.
一整天时间，从前一天傍晚起至第二天晚10点完成（包括challenge）。

Question 2.
Lab本身的练习感觉较简单，主要是阅读代码，可能和此前CSE课程已经做过关于文件系统的Lab有关。而实现challenge的过程比较困难，通过完成challenge进一步熟悉、巩固了关于链接、汇编语言、进程地址空间的知识。

Challenge.
    实现了Exercise 8后附的Challenge：实现Unix-style exec。根据其对练习8的描述，我的理解是在用户态实现exec调用，这将比实现spawn更困难。
    在exec调用中，加载者和被加载者相同，如果不借助内核作为中介，一定会在调用途中发生由于产生的不一致导致调用无法继续。我对于这个问题的解决方案基于这样一个假设：操作系统与用户程序间的运行时环境层保持不变，这样一来，不同进程尽管自身的代码不同，其依赖于的库函数（其中包括exec调用）相同，这一部分不需要在运行exec时替换掉。具体而言，就是修改user.ld，在用户程序中新增两个section，分别为.lib和.libdata，两者构成.lib段，加载到0x08000000开始的虚拟地址，这样就可以保证程序不进入内核就能完成整个exec调用的过程（.lib段中的代码起到了hypervisor的作用，在整个过程中保持不变）。对于需要修改的函数和变量，只需使用gcc的attribute功能为其指定section即可。
    exec的执行过程大致如下：首先在UTEMP处开辟一页存放新栈的内容，将通过argv传入的参数以及目标程序的入口点放置到该栈上；接着将所有进程当前占用的页unmap（除fd table，UTEMP自身等少数页外）并从目标程序的ELF文件中读取可加载的段载入内存，对于只读的段，先将其内容写到UTEMP2（UTEMP+PGSIZE）处，再用sys_page_map映射到实际位置并设置权限为只读；最后，为了将栈正确设置，先将栈临时移到UTEMP2，然后将UTEMP中已存好的新栈的内容映射到USTACKTOP-PGSIZE处，最后加载新栈，将UTEMP和UTEMP2都unmap。最终，利用第一步在栈上放置的入口点，通过一条ret指令即可开始运行新加载的程序。
    为了测试添加的功能，将icode中的spawn调用换成了exec，称为icode2，加入kern/Makefrag，经测试运行结果和icode一致，说明实现基本正确。
